// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package proto

import (
	"strconv"

	flatbuffers "github.com/google/flatbuffers/go"
)

type StartPosition byte

const (
	StartPosition_NEW_ONLY  StartPosition = 0
	StartPosition_OFFSET    StartPosition = 1
	StartPosition_EARLIEST  StartPosition = 2
	StartPosition_LATEST    StartPosition = 3
	StartPosition_TIMESTAMP StartPosition = 4
)

var EnumNamesStartPosition = map[StartPosition]string{
	StartPosition_NEW_ONLY:  "NEW_ONLY",
	StartPosition_OFFSET:    "OFFSET",
	StartPosition_EARLIEST:  "EARLIEST",
	StartPosition_LATEST:    "LATEST",
	StartPosition_TIMESTAMP: "TIMESTAMP",
}

var EnumValuesStartPosition = map[string]StartPosition{
	"NEW_ONLY":  StartPosition_NEW_ONLY,
	"OFFSET":    StartPosition_OFFSET,
	"EARLIEST":  StartPosition_EARLIEST,
	"LATEST":    StartPosition_LATEST,
	"TIMESTAMP": StartPosition_TIMESTAMP,
}

func (v StartPosition) String() string {
	if s, ok := EnumNamesStartPosition[v]; ok {
		return s
	}
	return "StartPosition(" + strconv.FormatInt(int64(v), 10) + ")"
}

type StreamMetadataError byte

const (
	StreamMetadataError_OK             StreamMetadataError = 0
	StreamMetadataError_UNKNOWN_STREAM StreamMetadataError = 1
)

var EnumNamesStreamMetadataError = map[StreamMetadataError]string{
	StreamMetadataError_OK:             "OK",
	StreamMetadataError_UNKNOWN_STREAM: "UNKNOWN_STREAM",
}

var EnumValuesStreamMetadataError = map[string]StreamMetadataError{
	"OK":             StreamMetadataError_OK,
	"UNKNOWN_STREAM": StreamMetadataError_UNKNOWN_STREAM,
}

func (v StreamMetadataError) String() string {
	if s, ok := EnumNamesStreamMetadataError[v]; ok {
		return s
	}
	return "StreamMetadataError(" + strconv.FormatInt(int64(v), 10) + ")"
}

type AckPolicy byte

const (
	AckPolicy_LEADER AckPolicy = 0
	AckPolicy_ALL    AckPolicy = 1
	AckPolicy_NONE   AckPolicy = 2
)

var EnumNamesAckPolicy = map[AckPolicy]string{
	AckPolicy_LEADER: "LEADER",
	AckPolicy_ALL:    "ALL",
	AckPolicy_NONE:   "NONE",
}

var EnumValuesAckPolicy = map[string]AckPolicy{
	"LEADER": AckPolicy_LEADER,
	"ALL":    AckPolicy_ALL,
	"NONE":   AckPolicy_NONE,
}

func (v AckPolicy) String() string {
	if s, ok := EnumNamesAckPolicy[v]; ok {
		return s
	}
	return "AckPolicy(" + strconv.FormatInt(int64(v), 10) + ")"
}

type CreateStreamRequest struct {
	Subject string
	Name string
	Group string
	ReplicationFactor int32
	Partitions int32
}

func CreateStreamRequestPack(builder *flatbuffers.Builder, t *CreateStreamRequest) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	subjectOffset := builder.CreateString(t.Subject)
	nameOffset := builder.CreateString(t.Name)
	groupOffset := builder.CreateString(t.Group)
	CreateStreamRequestStart(builder)
	CreateStreamRequestAddSubject(builder, subjectOffset)
	CreateStreamRequestAddName(builder, nameOffset)
	CreateStreamRequestAddGroup(builder, groupOffset)
	CreateStreamRequestAddReplicationFactor(builder, t.ReplicationFactor)
	CreateStreamRequestAddPartitions(builder, t.Partitions)
	return CreateStreamRequestEnd(builder)
}

func (rcv *CreateStreamRequestReceiver) UnPackTo(t *CreateStreamRequest) {
	t.Subject = string(rcv.Subject())
	t.Name = string(rcv.Name())
	t.Group = string(rcv.Group())
	t.ReplicationFactor = rcv.ReplicationFactor()
	t.Partitions = rcv.Partitions()
}

func (rcv *CreateStreamRequestReceiver) UnPack() *CreateStreamRequest {
	if rcv == nil { return nil }
	t := &CreateStreamRequest{}
	rcv.UnPackTo(t)
	return t
}

func (t *CreateStreamRequest) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(CreateStreamRequestPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *CreateStreamRequest) Unmarshal(data []byte) error {
	GetRootAsCreateStreamRequestReceiver(data, 0).UnPackTo(t)
	return nil
}

type CreateStreamRequestReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsCreateStreamRequestReceiver(buf []byte, offset flatbuffers.UOffsetT) *CreateStreamRequestReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CreateStreamRequestReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *CreateStreamRequestReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CreateStreamRequestReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *CreateStreamRequestReceiver) Subject() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *CreateStreamRequestReceiver) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *CreateStreamRequestReceiver) Group() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *CreateStreamRequestReceiver) ReplicationFactor() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *CreateStreamRequestReceiver) MutateReplicationFactor(n int32) bool {
	return rcv._tab.MutateInt32Slot(10, n)
}

func (rcv *CreateStreamRequestReceiver) Partitions() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *CreateStreamRequestReceiver) MutatePartitions(n int32) bool {
	return rcv._tab.MutateInt32Slot(12, n)
}

func CreateStreamRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func CreateStreamRequestAddSubject(builder *flatbuffers.Builder, subject flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(subject), 0)
}
func CreateStreamRequestAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func CreateStreamRequestAddGroup(builder *flatbuffers.Builder, group flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(group), 0)
}
func CreateStreamRequestAddReplicationFactor(builder *flatbuffers.Builder, replicationFactor int32) {
	builder.PrependInt32Slot(3, replicationFactor, 0)
}
func CreateStreamRequestAddPartitions(builder *flatbuffers.Builder, partitions int32) {
	builder.PrependInt32Slot(4, partitions, 0)
}
func CreateStreamRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type CreateStreamResponse struct {
}

func CreateStreamResponsePack(builder *flatbuffers.Builder, t *CreateStreamResponse) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	CreateStreamResponseStart(builder)
	return CreateStreamResponseEnd(builder)
}

func (rcv *CreateStreamResponseReceiver) UnPackTo(t *CreateStreamResponse) {
}

func (rcv *CreateStreamResponseReceiver) UnPack() *CreateStreamResponse {
	if rcv == nil { return nil }
	t := &CreateStreamResponse{}
	rcv.UnPackTo(t)
	return t
}

func (t *CreateStreamResponse) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(CreateStreamResponsePack(b, t))
	return b.FinishedBytes(), nil
}

func (t *CreateStreamResponse) Unmarshal(data []byte) error {
	GetRootAsCreateStreamResponseReceiver(data, 0).UnPackTo(t)
	return nil
}

type CreateStreamResponseReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsCreateStreamResponseReceiver(buf []byte, offset flatbuffers.UOffsetT) *CreateStreamResponseReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CreateStreamResponseReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *CreateStreamResponseReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CreateStreamResponseReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func CreateStreamResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func CreateStreamResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type SubscribeRequest struct {
	Stream string
	Partition int32
	StartPosition StartPosition
	StartOffset int64
	StartTimestamp int64
}

func SubscribeRequestPack(builder *flatbuffers.Builder, t *SubscribeRequest) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	streamOffset := builder.CreateString(t.Stream)
	SubscribeRequestStart(builder)
	SubscribeRequestAddStream(builder, streamOffset)
	SubscribeRequestAddPartition(builder, t.Partition)
	SubscribeRequestAddStartPosition(builder, t.StartPosition)
	SubscribeRequestAddStartOffset(builder, t.StartOffset)
	SubscribeRequestAddStartTimestamp(builder, t.StartTimestamp)
	return SubscribeRequestEnd(builder)
}

func (rcv *SubscribeRequestReceiver) UnPackTo(t *SubscribeRequest) {
	t.Stream = string(rcv.Stream())
	t.Partition = rcv.Partition()
	t.StartPosition = rcv.StartPosition()
	t.StartOffset = rcv.StartOffset()
	t.StartTimestamp = rcv.StartTimestamp()
}

func (rcv *SubscribeRequestReceiver) UnPack() *SubscribeRequest {
	if rcv == nil { return nil }
	t := &SubscribeRequest{}
	rcv.UnPackTo(t)
	return t
}

func (t *SubscribeRequest) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(SubscribeRequestPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *SubscribeRequest) Unmarshal(data []byte) error {
	GetRootAsSubscribeRequestReceiver(data, 0).UnPackTo(t)
	return nil
}

type SubscribeRequestReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsSubscribeRequestReceiver(buf []byte, offset flatbuffers.UOffsetT) *SubscribeRequestReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SubscribeRequestReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *SubscribeRequestReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SubscribeRequestReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SubscribeRequestReceiver) Stream() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *SubscribeRequestReceiver) Partition() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SubscribeRequestReceiver) MutatePartition(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *SubscribeRequestReceiver) StartPosition() StartPosition {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return StartPosition(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *SubscribeRequestReceiver) MutateStartPosition(n StartPosition) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *SubscribeRequestReceiver) StartOffset() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SubscribeRequestReceiver) MutateStartOffset(n int64) bool {
	return rcv._tab.MutateInt64Slot(10, n)
}

func (rcv *SubscribeRequestReceiver) StartTimestamp() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SubscribeRequestReceiver) MutateStartTimestamp(n int64) bool {
	return rcv._tab.MutateInt64Slot(12, n)
}

func SubscribeRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func SubscribeRequestAddStream(builder *flatbuffers.Builder, stream flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(stream), 0)
}
func SubscribeRequestAddPartition(builder *flatbuffers.Builder, partition int32) {
	builder.PrependInt32Slot(1, partition, 0)
}
func SubscribeRequestAddStartPosition(builder *flatbuffers.Builder, startPosition StartPosition) {
	builder.PrependByteSlot(2, byte(startPosition), 0)
}
func SubscribeRequestAddStartOffset(builder *flatbuffers.Builder, startOffset int64) {
	builder.PrependInt64Slot(3, startOffset, 0)
}
func SubscribeRequestAddStartTimestamp(builder *flatbuffers.Builder, startTimestamp int64) {
	builder.PrependInt64Slot(4, startTimestamp, 0)
}
func SubscribeRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type FetchMetadataRequest struct {
	Streams []string
}

func FetchMetadataRequestPack(builder *flatbuffers.Builder, t *FetchMetadataRequest) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	streamsOffset := flatbuffers.UOffsetT(0)
	if t.Streams != nil {
		streamsLength := len(t.Streams)
		streamsOffsets := make([]flatbuffers.UOffsetT, streamsLength)
		for j := 0; j < streamsLength; j++ {
			streamsOffsets[j] = builder.CreateString(t.Streams[j])
		}
		FetchMetadataRequestStartStreamsVector(builder, streamsLength)
		for j := streamsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(streamsOffsets[j])
		}
		streamsOffset = builder.EndVector(streamsLength)
	}
	FetchMetadataRequestStart(builder)
	FetchMetadataRequestAddStreams(builder, streamsOffset)
	return FetchMetadataRequestEnd(builder)
}

func (rcv *FetchMetadataRequestReceiver) UnPackTo(t *FetchMetadataRequest) {
	streamsLength := rcv.StreamsLength()
	t.Streams = make([]string, streamsLength)
	for j := 0; j < streamsLength; j++ {
		t.Streams[j] = string(rcv.Streams(j))
	}
}

func (rcv *FetchMetadataRequestReceiver) UnPack() *FetchMetadataRequest {
	if rcv == nil { return nil }
	t := &FetchMetadataRequest{}
	rcv.UnPackTo(t)
	return t
}

func (t *FetchMetadataRequest) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(FetchMetadataRequestPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *FetchMetadataRequest) Unmarshal(data []byte) error {
	GetRootAsFetchMetadataRequestReceiver(data, 0).UnPackTo(t)
	return nil
}

type FetchMetadataRequestReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsFetchMetadataRequestReceiver(buf []byte, offset flatbuffers.UOffsetT) *FetchMetadataRequestReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FetchMetadataRequestReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *FetchMetadataRequestReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FetchMetadataRequestReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *FetchMetadataRequestReceiver) Streams(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *FetchMetadataRequestReceiver) StreamsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func FetchMetadataRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func FetchMetadataRequestAddStreams(builder *flatbuffers.Builder, streams flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(streams), 0)
}
func FetchMetadataRequestStartStreamsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func FetchMetadataRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type FetchMetadataResponse struct {
	Brokers []*Broker
	Metadata []*StreamMetadata
}

func FetchMetadataResponsePack(builder *flatbuffers.Builder, t *FetchMetadataResponse) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	brokersOffset := flatbuffers.UOffsetT(0)
	if t.Brokers != nil {
		brokersLength := len(t.Brokers)
		brokersOffsets := make([]flatbuffers.UOffsetT, brokersLength)
		for j := 0; j < brokersLength; j++ {
			brokersOffsets[j] = BrokerPack(builder, t.Brokers[j])
		}
		FetchMetadataResponseStartBrokersVector(builder, brokersLength)
		for j := brokersLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(brokersOffsets[j])
		}
		brokersOffset = builder.EndVector(brokersLength)
	}
	metadataOffset := flatbuffers.UOffsetT(0)
	if t.Metadata != nil {
		metadataLength := len(t.Metadata)
		metadataOffsets := make([]flatbuffers.UOffsetT, metadataLength)
		for j := 0; j < metadataLength; j++ {
			metadataOffsets[j] = StreamMetadataPack(builder, t.Metadata[j])
		}
		FetchMetadataResponseStartMetadataVector(builder, metadataLength)
		for j := metadataLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(metadataOffsets[j])
		}
		metadataOffset = builder.EndVector(metadataLength)
	}
	FetchMetadataResponseStart(builder)
	FetchMetadataResponseAddBrokers(builder, brokersOffset)
	FetchMetadataResponseAddMetadata(builder, metadataOffset)
	return FetchMetadataResponseEnd(builder)
}

func (rcv *FetchMetadataResponseReceiver) UnPackTo(t *FetchMetadataResponse) {
	brokersLength := rcv.BrokersLength()
	t.Brokers = make([]*Broker, brokersLength)
	for j := 0; j < brokersLength; j++ {
		x := BrokerReceiver{}
		if rcv.Brokers(&x, j) {
			t.Brokers[j] = x.UnPack()
		}
	}
	metadataLength := rcv.MetadataLength()
	t.Metadata = make([]*StreamMetadata, metadataLength)
	for j := 0; j < metadataLength; j++ {
		x := StreamMetadataReceiver{}
		if rcv.Metadata(&x, j) {
			t.Metadata[j] = x.UnPack()
		}
	}
}

func (rcv *FetchMetadataResponseReceiver) UnPack() *FetchMetadataResponse {
	if rcv == nil { return nil }
	t := &FetchMetadataResponse{}
	rcv.UnPackTo(t)
	return t
}

func (t *FetchMetadataResponse) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(FetchMetadataResponsePack(b, t))
	return b.FinishedBytes(), nil
}

func (t *FetchMetadataResponse) Unmarshal(data []byte) error {
	GetRootAsFetchMetadataResponseReceiver(data, 0).UnPackTo(t)
	return nil
}

type FetchMetadataResponseReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsFetchMetadataResponseReceiver(buf []byte, offset flatbuffers.UOffsetT) *FetchMetadataResponseReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FetchMetadataResponseReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *FetchMetadataResponseReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FetchMetadataResponseReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *FetchMetadataResponseReceiver) Brokers(obj *BrokerReceiver, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *FetchMetadataResponseReceiver) BrokersLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *FetchMetadataResponseReceiver) Metadata(obj *StreamMetadataReceiver, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *FetchMetadataResponseReceiver) MetadataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func FetchMetadataResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func FetchMetadataResponseAddBrokers(builder *flatbuffers.Builder, brokers flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(brokers), 0)
}
func FetchMetadataResponseStartBrokersVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func FetchMetadataResponseAddMetadata(builder *flatbuffers.Builder, metadata flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(metadata), 0)
}
func FetchMetadataResponseStartMetadataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func FetchMetadataResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type PublishRequest struct {
	Message *Message
}

func PublishRequestPack(builder *flatbuffers.Builder, t *PublishRequest) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	messageOffset := MessagePack(builder, t.Message)
	PublishRequestStart(builder)
	PublishRequestAddMessage(builder, messageOffset)
	return PublishRequestEnd(builder)
}

func (rcv *PublishRequestReceiver) UnPackTo(t *PublishRequest) {
	t.Message = rcv.Message(nil).UnPack()
}

func (rcv *PublishRequestReceiver) UnPack() *PublishRequest {
	if rcv == nil { return nil }
	t := &PublishRequest{}
	rcv.UnPackTo(t)
	return t
}

func (t *PublishRequest) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(PublishRequestPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *PublishRequest) Unmarshal(data []byte) error {
	GetRootAsPublishRequestReceiver(data, 0).UnPackTo(t)
	return nil
}

type PublishRequestReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsPublishRequestReceiver(buf []byte, offset flatbuffers.UOffsetT) *PublishRequestReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PublishRequestReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *PublishRequestReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PublishRequestReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PublishRequestReceiver) Message(obj *MessageReceiver) *MessageReceiver {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(MessageReceiver)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func PublishRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func PublishRequestAddMessage(builder *flatbuffers.Builder, message flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(message), 0)
}
func PublishRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type PublishResponse struct {
	Ack *Ack
}

func PublishResponsePack(builder *flatbuffers.Builder, t *PublishResponse) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	ackOffset := AckPack(builder, t.Ack)
	PublishResponseStart(builder)
	PublishResponseAddAck(builder, ackOffset)
	return PublishResponseEnd(builder)
}

func (rcv *PublishResponseReceiver) UnPackTo(t *PublishResponse) {
	t.Ack = rcv.Ack(nil).UnPack()
}

func (rcv *PublishResponseReceiver) UnPack() *PublishResponse {
	if rcv == nil { return nil }
	t := &PublishResponse{}
	rcv.UnPackTo(t)
	return t
}

func (t *PublishResponse) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(PublishResponsePack(b, t))
	return b.FinishedBytes(), nil
}

func (t *PublishResponse) Unmarshal(data []byte) error {
	GetRootAsPublishResponseReceiver(data, 0).UnPackTo(t)
	return nil
}

type PublishResponseReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsPublishResponseReceiver(buf []byte, offset flatbuffers.UOffsetT) *PublishResponseReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PublishResponseReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *PublishResponseReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PublishResponseReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PublishResponseReceiver) Ack(obj *AckReceiver) *AckReceiver {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(AckReceiver)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func PublishResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func PublishResponseAddAck(builder *flatbuffers.Builder, ack flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ack), 0)
}
func PublishResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Broker struct {
	Id string
	Host string
	Port int32
}

func BrokerPack(builder *flatbuffers.Builder, t *Broker) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	idOffset := builder.CreateString(t.Id)
	hostOffset := builder.CreateString(t.Host)
	BrokerStart(builder)
	BrokerAddId(builder, idOffset)
	BrokerAddHost(builder, hostOffset)
	BrokerAddPort(builder, t.Port)
	return BrokerEnd(builder)
}

func (rcv *BrokerReceiver) UnPackTo(t *Broker) {
	t.Id = string(rcv.Id())
	t.Host = string(rcv.Host())
	t.Port = rcv.Port()
}

func (rcv *BrokerReceiver) UnPack() *Broker {
	if rcv == nil { return nil }
	t := &Broker{}
	rcv.UnPackTo(t)
	return t
}

func (t *Broker) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(BrokerPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *Broker) Unmarshal(data []byte) error {
	GetRootAsBrokerReceiver(data, 0).UnPackTo(t)
	return nil
}

type BrokerReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsBrokerReceiver(buf []byte, offset flatbuffers.UOffsetT) *BrokerReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &BrokerReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *BrokerReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *BrokerReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *BrokerReceiver) Id() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *BrokerReceiver) Host() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *BrokerReceiver) Port() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *BrokerReceiver) MutatePort(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func BrokerStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func BrokerAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0)
}
func BrokerAddHost(builder *flatbuffers.Builder, host flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(host), 0)
}
func BrokerAddPort(builder *flatbuffers.Builder, port int32) {
	builder.PrependInt32Slot(2, port, 0)
}
func BrokerEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type StreamMetadata struct {
	Name string
	Subject string
	Error StreamMetadataError
	Partitions []*PartitionMetadata
}

func StreamMetadataPack(builder *flatbuffers.Builder, t *StreamMetadata) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	nameOffset := builder.CreateString(t.Name)
	subjectOffset := builder.CreateString(t.Subject)
	partitionsOffset := flatbuffers.UOffsetT(0)
	if t.Partitions != nil {
		partitionsLength := len(t.Partitions)
		partitionsOffsets := make([]flatbuffers.UOffsetT, partitionsLength)
		for j := 0; j < partitionsLength; j++ {
			partitionsOffsets[j] = PartitionMetadataPack(builder, t.Partitions[j])
		}
		StreamMetadataStartPartitionsVector(builder, partitionsLength)
		for j := partitionsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(partitionsOffsets[j])
		}
		partitionsOffset = builder.EndVector(partitionsLength)
	}
	StreamMetadataStart(builder)
	StreamMetadataAddName(builder, nameOffset)
	StreamMetadataAddSubject(builder, subjectOffset)
	StreamMetadataAddError(builder, t.Error)
	StreamMetadataAddPartitions(builder, partitionsOffset)
	return StreamMetadataEnd(builder)
}

func (rcv *StreamMetadataReceiver) UnPackTo(t *StreamMetadata) {
	t.Name = string(rcv.Name())
	t.Subject = string(rcv.Subject())
	t.Error = rcv.Error()
	partitionsLength := rcv.PartitionsLength()
	t.Partitions = make([]*PartitionMetadata, partitionsLength)
	for j := 0; j < partitionsLength; j++ {
		x := PartitionMetadataReceiver{}
		if rcv.Partitions(&x, j) {
			t.Partitions[j] = x.UnPack()
		}
	}
}

func (rcv *StreamMetadataReceiver) UnPack() *StreamMetadata {
	if rcv == nil { return nil }
	t := &StreamMetadata{}
	rcv.UnPackTo(t)
	return t
}

func (t *StreamMetadata) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(StreamMetadataPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *StreamMetadata) Unmarshal(data []byte) error {
	GetRootAsStreamMetadataReceiver(data, 0).UnPackTo(t)
	return nil
}

type StreamMetadataReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsStreamMetadataReceiver(buf []byte, offset flatbuffers.UOffsetT) *StreamMetadataReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &StreamMetadataReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *StreamMetadataReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *StreamMetadataReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *StreamMetadataReceiver) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *StreamMetadataReceiver) Subject() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *StreamMetadataReceiver) Error() StreamMetadataError {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return StreamMetadataError(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *StreamMetadataReceiver) MutateError(n StreamMetadataError) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *StreamMetadataReceiver) Partitions(obj *PartitionMetadataReceiver, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *StreamMetadataReceiver) PartitionsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func StreamMetadataStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func StreamMetadataAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(name), 0)
}
func StreamMetadataAddSubject(builder *flatbuffers.Builder, subject flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(subject), 0)
}
func StreamMetadataAddError(builder *flatbuffers.Builder, error StreamMetadataError) {
	builder.PrependByteSlot(2, byte(error), 0)
}
func StreamMetadataAddPartitions(builder *flatbuffers.Builder, partitions flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(partitions), 0)
}
func StreamMetadataStartPartitionsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func StreamMetadataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type PartitionMetadata struct {
	Id int32
	Leader string
	Replicas []string
	Isr []string
}

func PartitionMetadataPack(builder *flatbuffers.Builder, t *PartitionMetadata) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	leaderOffset := builder.CreateString(t.Leader)
	replicasOffset := flatbuffers.UOffsetT(0)
	if t.Replicas != nil {
		replicasLength := len(t.Replicas)
		replicasOffsets := make([]flatbuffers.UOffsetT, replicasLength)
		for j := 0; j < replicasLength; j++ {
			replicasOffsets[j] = builder.CreateString(t.Replicas[j])
		}
		PartitionMetadataStartReplicasVector(builder, replicasLength)
		for j := replicasLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(replicasOffsets[j])
		}
		replicasOffset = builder.EndVector(replicasLength)
	}
	isrOffset := flatbuffers.UOffsetT(0)
	if t.Isr != nil {
		isrLength := len(t.Isr)
		isrOffsets := make([]flatbuffers.UOffsetT, isrLength)
		for j := 0; j < isrLength; j++ {
			isrOffsets[j] = builder.CreateString(t.Isr[j])
		}
		PartitionMetadataStartIsrVector(builder, isrLength)
		for j := isrLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(isrOffsets[j])
		}
		isrOffset = builder.EndVector(isrLength)
	}
	PartitionMetadataStart(builder)
	PartitionMetadataAddId(builder, t.Id)
	PartitionMetadataAddLeader(builder, leaderOffset)
	PartitionMetadataAddReplicas(builder, replicasOffset)
	PartitionMetadataAddIsr(builder, isrOffset)
	return PartitionMetadataEnd(builder)
}

func (rcv *PartitionMetadataReceiver) UnPackTo(t *PartitionMetadata) {
	t.Id = rcv.Id()
	t.Leader = string(rcv.Leader())
	replicasLength := rcv.ReplicasLength()
	t.Replicas = make([]string, replicasLength)
	for j := 0; j < replicasLength; j++ {
		t.Replicas[j] = string(rcv.Replicas(j))
	}
	isrLength := rcv.IsrLength()
	t.Isr = make([]string, isrLength)
	for j := 0; j < isrLength; j++ {
		t.Isr[j] = string(rcv.Isr(j))
	}
}

func (rcv *PartitionMetadataReceiver) UnPack() *PartitionMetadata {
	if rcv == nil { return nil }
	t := &PartitionMetadata{}
	rcv.UnPackTo(t)
	return t
}

func (t *PartitionMetadata) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(PartitionMetadataPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *PartitionMetadata) Unmarshal(data []byte) error {
	GetRootAsPartitionMetadataReceiver(data, 0).UnPackTo(t)
	return nil
}

type PartitionMetadataReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsPartitionMetadataReceiver(buf []byte, offset flatbuffers.UOffsetT) *PartitionMetadataReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PartitionMetadataReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *PartitionMetadataReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PartitionMetadataReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PartitionMetadataReceiver) Id() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PartitionMetadataReceiver) MutateId(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *PartitionMetadataReceiver) Leader() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *PartitionMetadataReceiver) Replicas(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *PartitionMetadataReceiver) ReplicasLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *PartitionMetadataReceiver) Isr(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *PartitionMetadataReceiver) IsrLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func PartitionMetadataStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func PartitionMetadataAddId(builder *flatbuffers.Builder, id int32) {
	builder.PrependInt32Slot(0, id, 0)
}
func PartitionMetadataAddLeader(builder *flatbuffers.Builder, leader flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(leader), 0)
}
func PartitionMetadataAddReplicas(builder *flatbuffers.Builder, replicas flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(replicas), 0)
}
func PartitionMetadataStartReplicasVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func PartitionMetadataAddIsr(builder *flatbuffers.Builder, isr flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(isr), 0)
}
func PartitionMetadataStartIsrVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func PartitionMetadataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type MessageHeader struct {
	Key string
	Value []byte
}

func MessageHeaderPack(builder *flatbuffers.Builder, t *MessageHeader) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	keyOffset := builder.CreateString(t.Key)
	valueOffset := flatbuffers.UOffsetT(0)
	if t.Value != nil {
		valueOffset = builder.CreateByteString(t.Value)
	}
	MessageHeaderStart(builder)
	MessageHeaderAddKey(builder, keyOffset)
	MessageHeaderAddValue(builder, valueOffset)
	return MessageHeaderEnd(builder)
}

func (rcv *MessageHeaderReceiver) UnPackTo(t *MessageHeader) {
	t.Key = string(rcv.Key())
	t.Value = rcv.ValueBytes()
}

func (rcv *MessageHeaderReceiver) UnPack() *MessageHeader {
	if rcv == nil { return nil }
	t := &MessageHeader{}
	rcv.UnPackTo(t)
	return t
}

func (t *MessageHeader) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(MessageHeaderPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *MessageHeader) Unmarshal(data []byte) error {
	GetRootAsMessageHeaderReceiver(data, 0).UnPackTo(t)
	return nil
}

type MessageHeaderReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsMessageHeaderReceiver(buf []byte, offset flatbuffers.UOffsetT) *MessageHeaderReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &MessageHeaderReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *MessageHeaderReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *MessageHeaderReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *MessageHeaderReceiver) Key() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MessageHeaderReceiver) Value(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *MessageHeaderReceiver) ValueLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *MessageHeaderReceiver) ValueBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MessageHeaderReceiver) MutateValue(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func MessageHeaderStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func MessageHeaderAddKey(builder *flatbuffers.Builder, key flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(key), 0)
}
func MessageHeaderAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(value), 0)
}
func MessageHeaderStartValueVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func MessageHeaderEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Message struct {
	Offset int64
	Key []byte
	Value []byte
	Timestamp int64
	Subject string
	Reply string
	Headers []*MessageHeader
	AckInbox string
	CorrelationId string
	AckPolicy AckPolicy
}

func MessagePack(builder *flatbuffers.Builder, t *Message) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	keyOffset := flatbuffers.UOffsetT(0)
	if t.Key != nil {
		keyOffset = builder.CreateByteString(t.Key)
	}
	valueOffset := flatbuffers.UOffsetT(0)
	if t.Value != nil {
		valueOffset = builder.CreateByteString(t.Value)
	}
	subjectOffset := builder.CreateString(t.Subject)
	replyOffset := builder.CreateString(t.Reply)
	headersOffset := flatbuffers.UOffsetT(0)
	if t.Headers != nil {
		headersLength := len(t.Headers)
		headersOffsets := make([]flatbuffers.UOffsetT, headersLength)
		for j := 0; j < headersLength; j++ {
			headersOffsets[j] = MessageHeaderPack(builder, t.Headers[j])
		}
		MessageStartHeadersVector(builder, headersLength)
		for j := headersLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(headersOffsets[j])
		}
		headersOffset = builder.EndVector(headersLength)
	}
	ackInboxOffset := builder.CreateString(t.AckInbox)
	correlationIdOffset := builder.CreateString(t.CorrelationId)
	MessageStart(builder)
	MessageAddOffset(builder, t.Offset)
	MessageAddKey(builder, keyOffset)
	MessageAddValue(builder, valueOffset)
	MessageAddTimestamp(builder, t.Timestamp)
	MessageAddSubject(builder, subjectOffset)
	MessageAddReply(builder, replyOffset)
	MessageAddHeaders(builder, headersOffset)
	MessageAddAckInbox(builder, ackInboxOffset)
	MessageAddCorrelationId(builder, correlationIdOffset)
	MessageAddAckPolicy(builder, t.AckPolicy)
	return MessageEnd(builder)
}

func (rcv *MessageReceiver) UnPackTo(t *Message) {
	t.Offset = rcv.Offset()
	t.Key = rcv.KeyBytes()
	t.Value = rcv.ValueBytes()
	t.Timestamp = rcv.Timestamp()
	t.Subject = string(rcv.Subject())
	t.Reply = string(rcv.Reply())
	headersLength := rcv.HeadersLength()
	t.Headers = make([]*MessageHeader, headersLength)
	for j := 0; j < headersLength; j++ {
		x := MessageHeaderReceiver{}
		if rcv.Headers(&x, j) {
			t.Headers[j] = x.UnPack()
		}
	}
	t.AckInbox = string(rcv.AckInbox())
	t.CorrelationId = string(rcv.CorrelationId())
	t.AckPolicy = rcv.AckPolicy()
}

func (rcv *MessageReceiver) UnPack() *Message {
	if rcv == nil { return nil }
	t := &Message{}
	rcv.UnPackTo(t)
	return t
}

func (t *Message) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(MessagePack(b, t))
	return b.FinishedBytes(), nil
}

func (t *Message) Unmarshal(data []byte) error {
	GetRootAsMessageReceiver(data, 0).UnPackTo(t)
	return nil
}

type MessageReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsMessageReceiver(buf []byte, offset flatbuffers.UOffsetT) *MessageReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &MessageReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *MessageReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *MessageReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *MessageReceiver) Offset() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MessageReceiver) MutateOffset(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

func (rcv *MessageReceiver) Key(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *MessageReceiver) KeyLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *MessageReceiver) KeyBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MessageReceiver) MutateKey(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *MessageReceiver) Value(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *MessageReceiver) ValueLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *MessageReceiver) ValueBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MessageReceiver) MutateValue(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *MessageReceiver) Timestamp() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MessageReceiver) MutateTimestamp(n int64) bool {
	return rcv._tab.MutateInt64Slot(10, n)
}

func (rcv *MessageReceiver) Subject() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MessageReceiver) Reply() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MessageReceiver) Headers(obj *MessageHeaderReceiver, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *MessageReceiver) HeadersLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *MessageReceiver) AckInbox() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MessageReceiver) CorrelationId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MessageReceiver) AckPolicy() AckPolicy {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return AckPolicy(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *MessageReceiver) MutateAckPolicy(n AckPolicy) bool {
	return rcv._tab.MutateByteSlot(22, byte(n))
}

func MessageStart(builder *flatbuffers.Builder) {
	builder.StartObject(10)
}
func MessageAddOffset(builder *flatbuffers.Builder, offset int64) {
	builder.PrependInt64Slot(0, offset, 0)
}
func MessageAddKey(builder *flatbuffers.Builder, key flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(key), 0)
}
func MessageStartKeyVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func MessageAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(value), 0)
}
func MessageStartValueVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func MessageAddTimestamp(builder *flatbuffers.Builder, timestamp int64) {
	builder.PrependInt64Slot(3, timestamp, 0)
}
func MessageAddSubject(builder *flatbuffers.Builder, subject flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(subject), 0)
}
func MessageAddReply(builder *flatbuffers.Builder, reply flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(reply), 0)
}
func MessageAddHeaders(builder *flatbuffers.Builder, headers flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(headers), 0)
}
func MessageStartHeadersVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MessageAddAckInbox(builder *flatbuffers.Builder, ackInbox flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(ackInbox), 0)
}
func MessageAddCorrelationId(builder *flatbuffers.Builder, correlationId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(correlationId), 0)
}
func MessageAddAckPolicy(builder *flatbuffers.Builder, ackPolicy AckPolicy) {
	builder.PrependByteSlot(9, byte(ackPolicy), 0)
}
func MessageEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Ack struct {
	Stream string
	PartitionSubject string
	MsgSubject string
	Offset int64
	AckInbox string
	CorrelationId string
	AckPolicy AckPolicy
}

func AckPack(builder *flatbuffers.Builder, t *Ack) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	streamOffset := builder.CreateString(t.Stream)
	partitionSubjectOffset := builder.CreateString(t.PartitionSubject)
	msgSubjectOffset := builder.CreateString(t.MsgSubject)
	ackInboxOffset := builder.CreateString(t.AckInbox)
	correlationIdOffset := builder.CreateString(t.CorrelationId)
	AckStart(builder)
	AckAddStream(builder, streamOffset)
	AckAddPartitionSubject(builder, partitionSubjectOffset)
	AckAddMsgSubject(builder, msgSubjectOffset)
	AckAddOffset(builder, t.Offset)
	AckAddAckInbox(builder, ackInboxOffset)
	AckAddCorrelationId(builder, correlationIdOffset)
	AckAddAckPolicy(builder, t.AckPolicy)
	return AckEnd(builder)
}

func (rcv *AckReceiver) UnPackTo(t *Ack) {
	t.Stream = string(rcv.Stream())
	t.PartitionSubject = string(rcv.PartitionSubject())
	t.MsgSubject = string(rcv.MsgSubject())
	t.Offset = rcv.Offset()
	t.AckInbox = string(rcv.AckInbox())
	t.CorrelationId = string(rcv.CorrelationId())
	t.AckPolicy = rcv.AckPolicy()
}

func (rcv *AckReceiver) UnPack() *Ack {
	if rcv == nil { return nil }
	t := &Ack{}
	rcv.UnPackTo(t)
	return t
}

func (t *Ack) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(AckPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *Ack) Unmarshal(data []byte) error {
	GetRootAsAckReceiver(data, 0).UnPackTo(t)
	return nil
}

type AckReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsAckReceiver(buf []byte, offset flatbuffers.UOffsetT) *AckReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &AckReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *AckReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *AckReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *AckReceiver) Stream() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *AckReceiver) PartitionSubject() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *AckReceiver) MsgSubject() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *AckReceiver) Offset() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *AckReceiver) MutateOffset(n int64) bool {
	return rcv._tab.MutateInt64Slot(10, n)
}

func (rcv *AckReceiver) AckInbox() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *AckReceiver) CorrelationId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *AckReceiver) AckPolicy() AckPolicy {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return AckPolicy(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *AckReceiver) MutateAckPolicy(n AckPolicy) bool {
	return rcv._tab.MutateByteSlot(16, byte(n))
}

func AckStart(builder *flatbuffers.Builder) {
	builder.StartObject(7)
}
func AckAddStream(builder *flatbuffers.Builder, stream flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(stream), 0)
}
func AckAddPartitionSubject(builder *flatbuffers.Builder, partitionSubject flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(partitionSubject), 0)
}
func AckAddMsgSubject(builder *flatbuffers.Builder, msgSubject flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(msgSubject), 0)
}
func AckAddOffset(builder *flatbuffers.Builder, offset int64) {
	builder.PrependInt64Slot(3, offset, 0)
}
func AckAddAckInbox(builder *flatbuffers.Builder, ackInbox flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(ackInbox), 0)
}
func AckAddCorrelationId(builder *flatbuffers.Builder, correlationId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(correlationId), 0)
}
func AckAddAckPolicy(builder *flatbuffers.Builder, ackPolicy AckPolicy) {
	builder.PrependByteSlot(6, byte(ackPolicy), 0)
}
func AckEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
